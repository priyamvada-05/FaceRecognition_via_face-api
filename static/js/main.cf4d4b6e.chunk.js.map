{"version":3,"sources":["test_pic/test_img.jpeg","function_api/face_detect.js","component/BoundingBox/BoundingBox.js","component/ImageDisplay/ImageDisplay.js","component/WebCamCamera/WebCamCamera.js","container/Particle_constant.js","container/App.js","serviceWorker.js","index.js"],"names":["module","exports","loadModels","a","console","log","MODEL_URL","process","faceapi","getFaceDescription","img","inputSize","scoreThreshold","OPTION","useTinyModel","image","withFaceLandmarks","withFaceDescriptors","fullDesc","cordArray","map","obj","_height","detection","box","height","_x","_y","_width","BoundingBox","cord","container","i","width","key","className","style","transform","ImageDisplay","src","detectStatus","ImageUrl","type","placeholder","onChange","id","WebCamCamera","componentDidMount","startCapture","capture","webcam","current","getScreenshot","setState","faceDesc","interval","setInterval","React","createRef","state","videoConstraints","facingMode","clearInterval","this","audio","ref","screenshotFormat","Component","Particle_constant","App","sayHello","event","cameraStatus","then","faceDetected","getImageFromInput","target","value","camera","test_img","discription","params","onClick","status","Boolean","window","location","hostname","match","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","registration","unregister"],"mappings":"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","file":"static/js/main.cf4d4b6e.chunk.js","sourcesContent":["module.exports = __webpack_public_path__ + \"static/media/test_img.5301fbed.jpeg\";","\r\nimport * as faceapi from 'face-api.js';\r\n\r\n// Load models and weights\r\nexport const loadModels= async ()=> {\r\n\tconsole.log('Loading models')\r\n  const MODEL_URL = process.env.PUBLIC_URL + '/models';\r\n  await faceapi.loadTinyFaceDetectorModel(MODEL_URL);\r\n  await faceapi.loadFaceLandmarkTinyModel(MODEL_URL);\r\n  await faceapi.loadFaceRecognitionModel(MODEL_URL);\r\n}\r\n\r\nexport const getFaceDescription= async (img, inputSize=512)=>{\r\n\r\n\tconsole.log('Models loaded')\r\n\tlet scoreThreshold = 0.5;\r\n  \tconst OPTION = new faceapi.TinyFaceDetectorOptions({\r\n    inputSize,\r\n    scoreThreshold\r\n \t });\r\n  \tconst useTinyModel = true;\r\n\r\n  // fetch image to api\r\n\t  let image = await faceapi.fetchImage(img);\r\n\r\n\t  // detect all faces and generate full description from image\r\n\t  // including landmark and descriptor of each face\r\n\t  let fullDesc = await faceapi\r\n\t    .detectAllFaces(image, OPTION)\r\n\t    .withFaceLandmarks(useTinyModel)\r\n\t    .withFaceDescriptors();\r\n\r\n\t  let cordArray=fullDesc.map(obj=>{\r\n\r\n\t  \tconst _height=obj.detection.box.height;\r\n\t\tconst _x=obj.detection.box._x;\r\n\t\tconst _y=obj.detection.box._y;\r\n\t\tconst _width=obj.detection.box._width;\r\n\r\n\r\n\t\treturn({\r\n\t\t\t_height,\r\n\t\t\t_x,\r\n\t\t\t_y,\r\n\t\t\t_width\r\n\t\t})\r\n\t  })\r\n\r\n\t  return( {\r\n\t  \t  \t      fullDesc,\r\n\t  \t  \t      cordArray\r\n\t  });\r\n\t  }","import React from 'react';\r\nimport './BoundingBox.css';\r\n\r\nconst BoundingBox=  ({container})=>{\r\n\r\n\t  \r\n\t\tconst cord=container.map((obj,i)=>{\r\n\r\n\t\t\tconsole.log(obj)\r\n\t\t\tlet height = obj._height;\r\n\t        let _x = obj._x;\r\n\t        let _y = obj._y;\r\n\t        let width = obj._width;\r\n\r\n\t\t\treturn(<div key={i} className=\"bounding-box\" \r\n\t\t\t\t style={{width:width, height:height,  transform: `translate(${_x}px,${_y}px)`}}>\r\n\t\t          </div>)\r\n\t\t});\r\n\r\n\t\treturn(\r\n\r\n\t\t\t<div>\r\n\t\t\t\t{cord}\r\n\t\t\t</div>\r\n\t\t\t)\r\n\t\t\t\t}\r\n\r\n\r\n\r\nexport default BoundingBox","import React from 'react';\r\nimport BoundingBox from '../BoundingBox/BoundingBox'\r\nimport './ImageDisplay.css'\r\n\r\n\r\nconst ImageDisplay=({src, container,detectStatus,ImageUrl})=>{\r\n\r\n\r\n\t\t\treturn(\r\n\t\t\t\t<div  className='center' width='770' height='auto'>\r\n\t\t\t\t\r\n\t\t\t\t<div className='new1'>\r\n\t\t\t\t<input type='text' placeholder='Enter the url' className='w-50 shadow-5 f4 mb3' onChange={ImageUrl} />\r\n\t\t\t\t</div>\r\n\t\t\t\t<div className='new' >\r\n\t\t\t\t\t\t{detectStatus ? \r\n\t\t\t\t\t\t\t( <BoundingBox container={container} /> )\r\n\t\t\t\t\t\t\t: null\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t<img src={src} id='new'/>\r\n\t\t \t\t\r\n\t\t\t\t</div>\r\n\t\t\t\t</div>\r\n\t\t);\r\n\r\n\t\t}\r\n\r\n\r\nexport default ImageDisplay","import React, {Component} from \"react\";\r\nimport Webcam from \"react-webcam\";\r\nimport './WebCamCamera.css'\r\nimport BoundingBox from '../BoundingBox/BoundingBox'\r\nimport { loadModels,getFaceDescription } from '../../function_api/face_detect';\r\n\r\nclass  WebCamCamera extends Component {\r\n \r\n \tconstructor(){\r\n \t\tsuper()\r\n \t\tconsole.log('we are on web cam')\r\n \t\tthis.webcam = React.createRef();\r\n \t\tthis.state={\r\n \t\t\tvideoConstraints: {\r\n\t\t\t\t  width: 800,\r\n\t\t\t\t  height: 400,\r\n\t\t\t\t  facingMode: \"user\"},\r\n\t\t\tinputSize: {\r\n\t\t\t\twidth:'800px',\r\n\t\t\t\theight:'400px'\r\n\t\t\t},\r\n\t\t\tfaceDesc: null,\r\n\t\t\tbox:[]\r\n\t\t    }\r\n\r\n \t}\r\n\r\n \tcomponentDidMount= async () => {\r\n \t\tawait loadModels();\r\n \t\tthis.startCapture();\r\n        \r\n \t    }\r\n\r\n \tcomponentWillUnmount() {\r\n    clearInterval(this.interval);\r\n  }\r\n\r\n \t capture = async () => {\r\n \t \tconst obj=await getFaceDescription(this.webcam.current.getScreenshot())\r\n        this.setState({faceDesc: obj.fullDesc, box:obj.cordArray })\r\n        }\r\n  \r\n  \r\n\r\n      startCapture = () => {\r\n           this.interval = setInterval(() => {\r\n           this.capture();\r\n           }, 1500);\r\n        };\r\n\r\n        render(){\r\n\r\n        \t\treturn(\r\n        \t\t\t<div className='new mt3'>\r\n        \t \t\t\t<div className='rel'>\r\n        \t \t\t\t<BoundingBox container = {this.state.box}/>\r\n        \t \t\t\t<Webcam\r\n        \t \t\t\t  \tclassName=' shadow-5 br3'\r\n        \t \t\t\t    audio={false}\r\n        \t \t\t\t\theight={400}\r\n        \t \t\t\t\tref={this.webcam}\r\n        \t \t\t\t\tscreenshotFormat=\"image/jpeg\"\r\n        \t \t\t\t\twidth={800}\r\n        \t \t\t\t\tvideoConstraints={this.state.videoConstraints}\r\n        \t \t\t     />\r\n        \t \t\t\t </div>\r\n        \t \t\t\t</div>\r\n        \t\t\t)\r\n\r\n}\r\n}\r\n\r\n\r\n export default WebCamCamera;","export const Particle_constant = {\r\n      \"particles\": {\r\n          \"number\": {\r\n              \"value\": 250,\r\n              \"density\": {\r\n                  \"enable\": false\r\n              }\r\n          },\r\n          \"size\": {\r\n              \"value\": 10,\r\n              \"random\": true\r\n          },\r\n          \"move\": {\r\n              \"direction\": \"bottom\",\r\n              \"out_mode\": \"out\"\r\n          },\r\n          \"line_linked\": {\r\n              \"enable\": false\r\n          }\r\n      },\r\n      \"interactivity\": {\r\n          \"events\": {\r\n              \"onhover\": {\r\n                  \"enable\": true,\r\n                  \"mode\": \"remove\"\r\n              }\r\n          },\r\n          \"modes\": {\r\n              \"repulse\": {\r\n                  \"distance\":200,\r\n                  \"duration\":0.4\r\n              }\r\n          }\r\n      }\r\n  }","import React, { Component } from 'react';\nimport './App.css';\nimport test_img from '../test_pic/test_img.jpeg'\nimport { loadModels,getFaceDescription } from '../function_api/face_detect';\nimport ImageDisplay from '../component/ImageDisplay/ImageDisplay'\nimport WebCamCamera from '../component/WebCamCamera/WebCamCamera';\nimport Particles from 'react-particles-js';\nimport {Particle_constant} from './Particle_constant';\n\n\nclass App extends Component {\n\n  constructor() {\n    super();\n    this.state = { \n      image: test_img,\n      fullDesc: [],\n      box:[],\n      faceDetected:false,\n      discription:null,\n      cameraStatus:false\n    };\n  }\n\n  componentDidMount= async ()=> {\n     await loadModels();\n       };\n\n  sayHello=async (event)=>{\n      this.setState({cameraStatus:false})\n      await getFaceDescription(this.state.image).then(obj=> this.setState({\n      fullDesc:obj.fullDesc, \n      box:obj.cordArray ,\n      faceDetected: true\n       } ));\n     console.log(this.state.fullDesc);\n  }\n\n  getImageFromInput=(event)=>{\n\n      this.setState({image:event.target.value})\n  }\n\n  camera=(event)=>{\n        this.setState({cameraStatus:true})\n        console.log(this.state.cameraStatus)\n  }\n\n\n  render() {\n\n    return (\n      <div className=''>\n      <Particles className='particle' params={Particle_constant} />\n        <h1 className='f2 tc'>Welcome to the face recognition</h1>\n        <div className='container new'>\n        <button className='f3 br3 bg-light-green pointer mr3' onClick={this.sayHello}>Picture</button>\n        <button className='f3 br3 bg-light-green pointer' onClick={this.camera}>Camera</button>\n        </div>\n        <div className='new mt1'>\n        {/* />*/}\n        </div>\n        {this.state.cameraStatus?\n                (<WebCamCamera status={this.cameraStatus}/>)\n        \n                :(<ImageDisplay ImageUrl={this.getImageFromInput} container={this.state.box}  src={this.state.image} detectStatus={this.state.faceDetected} />)\n                }\n      </div>\n    );\n\n   }\n}\n\nexport default App","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './container/App';\nimport * as serviceWorker from './serviceWorker';\nimport 'tachyons'\n\nReactDOM.render(<App/>, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}